import tkinter as tk
from tkinter import ttk
import os
import time
import RPi.GPIO as GPIO
import subprocess
import sys
from threading import Thread
import shutil

# Add the printProgressBar function
def printProgressBar(iteration, total, prefix='', suffix='', usepercent=True, decimals=1, fill='█'):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        usepercent  - Optional  : display percentage (Bool)
        decimals    - Optional  : positive number of decimals in percent complete (Int), ignored if usepercent = False
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
    """
    twx, twy = shutil.get_terminal_size()
    length = twx - 1 - len(prefix) - len(suffix) - 4
    if usepercent:
        length = length - 6
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    if usepercent:
        percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
        print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end='', flush=True)
    else:
        print('\r%s |%s| %s' % (prefix, bar, suffix), end='', flush=True)
    if iteration == total:
        print(flush=True)

# Your existing code
input_pin_numbers = [8, 10, 19, 33, 35, 18, 7]  # used for LED, determines which output will be programmed
output_pin_numbers = [11, 13, 15, 29, 31, 37, 16]  # output used to program the CM4
g_pins = [[8, 11], [10, 13], [19, 15], [33, 29], [35, 31], [18, 37], [7, 16]]  # pairs of pins (input, output)

input_image = "/home/pi/Downloads/2024-07-04-raspios-bookworm-arm64.img.xz"

GPIO.setmode(GPIO.BOARD)
GPIO.setup(input_pin_numbers, GPIO.IN)  # Set pin as input
GPIO.setup(output_pin_numbers, GPIO.OUT)  # Set pin as output
GPIO.output(output_pin_numbers, 0)  # Initialize pin to LOW

def ONOFF(in_pin, out_pin, onoff_state):
    iter = 0
    max_iter = 3
    if onoff_state:
        while GPIO.input(in_pin) != onoff_state:
            GPIO.output(out_pin, 1)
            time.sleep(0.1)
            GPIO.output(out_pin, 0)
            time.sleep(0.5)
            if iter > max_iter:
                return -1
            iter += 1
        return 0
    return 0

def run_command(command, timeout=None):
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate(timeout=timeout)
        return process.returncode, output, error
    except subprocess.TimeoutExpired:
        process.kill()
        output, error = process.communicate()
        return -1, output, error

def FlushFirmwareProc(index, letter):
    command = f'sudo dd bs=4M if={input_image} of=/dev/sd{letter} conv=fsync status=progress > /home/pi/progress{letter} &'
    pcomm = os.system(command)
    if pcomm < 0:
        update_status(index, "Failed", "red")
    else:
        update_status(index, "In Progress", "blue")
        progress_file_name = f'/home/pi/progress{letter}'
        progress = 0
        while progress < 100:
            try:
                with open(progress_file_name, 'r') as file:
                    lines = file.readlines()
                    for line in lines:
                        if "bytes" in line:
                            # Extract the percentage progress from the status output
                            progress = int(line.split('%')[0].strip().split()[-1])
                # Update the progress bar in the terminal
                printProgressBar(progress, 100, prefix=f"Processing {index+1}", suffix="Complete")
                update_progress(index, progress)
                time.sleep(1)
            except FileNotFoundError:
                time.sleep(1)
        update_status(index, "Completed", "green")

def FlushFirmware(index, letter):
    Thread(target=FlushFirmwareProc, args=(index, letter)).start()

def buttonProc():
    letter = 'a'
    for index, pin in enumerate(g_pins):
        if InitializeUsb(pin[0], pin[1], letter, index) == 0:
            FlushFirmware(index, letter)
            letter = chr(ord(letter) + 1)

def InitializeUsb(in_pin, out_pin, letter, index):
    if ONOFF(in_pin, out_pin, True) != 0:
        update_status(index, "Failed", "red")
        return -1
    os.system("/home/pi/rpiboot_wraper.sh&")
    if wait_for_device(letter) == 0:
        update_status(index, "Success", "green")
        return 0
    update_status(index, "Failed", "red")
    return -1

def wait_for_device(letter):
    retries = 0
    fileName = f'/dev/sd{letter}'
    while retries < 10:
        time.sleep(2)
        if os.path.exists(fileName):
            return 0
        retries += 1
    return -1

def reset_pins():
    GPIO.output(output_pin_numbers, 0)
    for i in range(len(g_pins)):
        update_status(i, "Not started", "grey")
        update_progress(i, 0)

def on_closing():
    GPIO.cleanup()
    sys.exit(0)

def update_progress(index, value):
    progress_bars[index].config(value=value)
    window.update_idletasks()

def update_status(index, text, color):
    status_labels[index].config(text=f"Pin pair {index+1}: {text}", fg=color)
    star_labels[index].config(bg=color)

# GUI setup
window = tk.Tk()
window.title("Pin Status Monitor")

frame = tk.Frame(window)
frame.pack(padx=10, pady=10)

status_labels = []
progress_bars = []
star_labels = []

for i in range(len(g_pins)):
    status_label = tk.Label(frame, text=f"Pin pair {i+1}: Not started")
    status_label.grid(row=i, column=0, padx=5, pady=5)
    status_labels.append(status_label)

    progress_bar = ttk.Progressbar(frame, orient="horizontal", length=400, mode="determinate")
    progress_bar.grid(row=i, column=1, padx=5, pady=5)
    progress_bars.append(progress_bar)

    star_label = tk.Label(frame, text="★", font=("Arial", 20), bg='grey')
    star_label.grid(row=i, column=2, padx=5, pady=5)
    star_labels.append(star_label)

reset_button = tk.Button(window, text="Reset Pins", command=reset_pins)
reset_button.pack(pady=10)

run_button = tk.Button(window, text="Run Commands", command=lambda: Thread(target=buttonProc).start())
run_button.pack(pady=10)

window.protocol("WM_DELETE_WINDOW", on_closing)
window.mainloop()
