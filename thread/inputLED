import tkinter as tk
import os
import time
import RPi.GPIO as GPIO
import sys
import subprocess
from threading import Thread
#import logging

# Set GPIO pin numbering mode to BOARD, referenced by their physical location on the board.
GPIO.setmode(GPIO.BOARD)

# GPIO output pins used in the application
output_pin_numbers = [11, 13, 15, 29, 31, 37, 16] # CM4
# GPIO input pins for LEDs
input_pin_numbers = [8, 10, 19, 33, 35, 18, 7] # LEDs

# Initialize each output pin
for pin in output_pin_numbers:
    GPIO.setup(pin, GPIO.OUT)

# Initialize each input pin
for pin in input_pin_numbers:
    GPIO.setup(pin, GPIO.IN)

def run_command(command, timeout=None):
    try:
        # Start the command as a subprocess and get output and error
        #subprocess is more flexible than os, since you can it can inspect output and errors that occur
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate(timeout=timeout)
        return process.returncode, output, error
    except subprocess.TimeoutExpired:
#if the command times out, kill the process and return failure status
        process.kill()
        output, error = process.communicate()
        return -1, output, error
    #Run a shell command and capture its output (you can specify a timeout if needed)
    #Parameters: command: The shell command to run.
    #timeout: The maximum time (in seconds) to wait for the command to complete (None for no timeout).
    #Returns:(return_code, output, error):
    #return_code: Exit code of the command (0 for success, non-zero for error)."""

def handle_pin(pin):
    GPIO.output(pin, 1)
    time.sleep(1)
    command_success = False
    retries = 0
    letter = 'a'

    while not command_success and retries < 2:
        os.system("sudo /home/pi/usbboot/rpiboot")
        time.sleep(10)

        fileName = f'/dev/sd{letter}'
        if os.path.exists(fileName):
            command_success = True
            print(f"Device found at {fileName} for pin {pin}")
        else:
            print(f"Retrying command for pin {pin} (Attempt {retries + 1})")
            retries += 1
            letter = chr(ord(letter) + 1)

        if not command_success and retries == 2:
            os.system("sudo /home/pi/usbboot/rpiboot")
            time.sleep(10)
            letter = 'a'
            while not command_success and retries < 3:
                fileName = f'/dev/sd{letter}'
                if os.path.exists(fileName):
                    command_success = True
                    print(f"Device found at {fileName} for pin {pin}")
                else:
                    print(f"Retrying command for pin {pin} (Attempt {retries + 1})")
                    retries += 1
                    letter = chr(ord(letter) + 1)

    if command_success:
        dd_command = "sudo dd bs=4M if=Zyrlo_2022_08_14_RC1.img of=/dev/sdb conv=fsync"
        print("Running dd command...")
        ret_code, dd_output, dd_error = run_command(dd_command)
        while True:
            status_command = "status=progress"
            ret_code, status_output, status_error = run_command(status_command)
            if ret_code == 0:
                print("dd command completed successfully")
                break
            else:
                print(f"Error during status check: {status_error.decode()}")
                print(f"Output during status check: {status_output.decode()}")
            time.sleep(30)
    else:
        print(f"Command failed on pin {pin} after 3 attempts")

def buttonFunc():
    threads = []

    # Check the state of input pins
    input_states = [GPIO.input(pin) for pin in input_pin_numbers]

    # If any input pin is HIGH, start the process
    if any(input_states):
        # Set output pins to HIGH
        for pin in output_pin_numbers:
            GPIO.output(pin, GPIO.HIGH)
        
        for pin in output_pin_numbers:
            thread = Thread(target=handle_pin, args=(pin,))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()
    else:
        # Set output pins to LOW if no input pins are HIGH
        for pin in output_pin_numbers:
            GPIO.output(pin, GPIO.LOW)

def on_closing():
    GPIO.cleanup()
    print("GPIO cleaned up")
    sys.exit()

window = tk.Tk()
window.geometry("800x800")
window.protocol("WM_DELETE_WINDOW", on_closing)

button = tk.Button(window, text="Run Reboot", command=buttonFunc, fg='white', bg='black')
window.configure(bg='lightgrey')
button.pack(padx=50, pady=50)

try:
    window.mainloop()
except KeyboardInterrupt:
    print("KeyboardInterrupt caught, cleaning up GPIO and exiting")
    GPIO.cleanup()
    sys.exit()
