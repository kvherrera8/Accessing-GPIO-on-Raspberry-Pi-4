import tkinter as tk
import os
import time
import RPi.GPIO as GPIO
import sys

GPIO.setmode(GPIO.BOARD)

# Define GPIO pins
pin_numbers = [3, 5, 7, 11, 13, 15, 19]
for pin in pin_numbers:
    GPIO.setup(pin, GPIO.OUT)

def run_command(command, timeout=10):
    """ Run a command and return its output if it completes within the timeout period. """
    import subprocess
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate(timeout=timeout)
        return process.returncode, output, error
    except subprocess.TimeoutExpired:
        process.kill()
        output, error = process.communicate()
        return -1, output, error

def buttonFunc():
    print("Button Pressed")
    
    for pin in pin_numbers:
        GPIO.output(pin, 1)
        time.sleep(0.5)
        command_success = False
        retries = 0
        letter = 'a'
        
        while not command_success and retries < 2:
            os.system("sudo /home/pi/usbboot/rpiboot")

            # Wait for 10 seconds to give the system time to detect the device
            time.sleep(10)
            
            fileName = f'/dev/sd{letter}'
            if os.path.exists(fileName):
                command_success = True
                print(f"Device found at {fileName}")
            else:
                print(f"Retrying command for pin {pin} (Attempt {retries + 1})")
                retries += 1
                letter = chr(ord(letter) + 1)
                
            if not command_success and retries == 2:
                # Run the command one more time before final recheck
                os.system("sudo /home/pi/usbboot/rpiboot")
                time.sleep(10)  # Wait again to give time for detection
                # Check the letters again after running the command one more time
                letter = 'a'  # Reset letter to 'a'
                while not command_success and retries < 3:  # Allow one final attempt
                    fileName = f'/dev/sd{letter}'
                    if os.path.exists(fileName):
                        command_success = True
                        print(f"Device found at {fileName}")
                    else:
                        print(f"Retrying command for pin {pin} (Attempt {retries + 1})")
                        retries += 1
                        letter = chr(ord(letter) + 1)

        if not command_success:
            print(f"Command failed on pin {pin} after 3 attempts")
        else:
            # After successful GPIO initialization, run the dd command
            dd_command = "sudo dd bs=4M if=Zyrlo_2022_08_14_RC1.img of=/dev/sdb conv=fsync"
            print("Running dd command...")
            ret_code, dd_output, dd_error = run_command(dd_command)
            
            # Wait for 10 seconds and run status=progress
            time.sleep(10)
            
            status_command = "status=progress"
            print("Running status=progress...")
            ret_code, status_output, status_error = run_command(status_command)

            if ret_code == 0:
                print("Commands executed successfully")
            else:
                print(f"Error during dd or status command: {dd_error.decode()}")
                print(f"Output during dd command: {dd_output.decode()}")

        if not command_success:
            print(f"Command failed on pin {pin} after 3 attempts")
        else:
            break

def on_closing():
    GPIO.cleanup()
    print("GPIO cleaned up")
    sys.exit()  # Exit the program

# Set up the GUI
window = tk.Tk()
window.geometry("800x800")
window.protocol("WM_DELETE_WINDOW", on_closing)

button = tk.Button(window, text="Run Reboot", command=buttonFunc, fg='white', bg='black')
window.configure(bg='lightgrey')
button.pack(padx=50, pady=50)

try:
    window.mainloop()
except KeyboardInterrupt:
    print("KeyboardInterrupt caught, cleaning up GPIO and exiting")
    GPIO.cleanup()
    sys.exit()
