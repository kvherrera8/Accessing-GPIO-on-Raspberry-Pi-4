import tkinter as tk
from tkinter import ttk
import os
import time
import RPi.GPIO as GPIO
import sys
import subprocess
from threading import Thread
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# GPIO Configuration
GPIO.setmode(GPIO.BOARD)

# GPIO pin numbers
INPUT_PIN_NUMBERS = [8, 10, 19, 33, 35, 18, 7] #input pins (voltage)
OUTPUT_PIN_NUMBERS = [11, 13, 15, 29, 31, 37, 16] #output pins (no voltage)
G_PINS = [[8, 11], [10, 13], [19, 15], [33, 29], [35, 31], [18, 37], [7, 16]] #(input,output) 

# Setup GPIO pins
for pin in INPUT_PIN_NUMBERS:
    GPIO.setup(pin, GPIO.IN) #set as input

for pin in OUTPUT_PIN_NUMBERS:
    GPIO.setup(pin, GPIO.OUT) #set as output
    GPIO.output(pin, 0)  # Ensure all output pins are initially off

for pin_pair in G_PINS:
    GPIO.setup(pin_pair[0], GPIO.IN) #inpt pin
    GPIO.setup(pin_pair[1], GPIO.OUT) #output pin
    GPIO.output(pin_pair[1], 0)  # Ensure output pins are initially off

def ONOFF(in_pin, out_pin, onoff_state):
    iter = 0 #initialize iter counter to 0/zero
    max_iter = 3 #set max iter to 3
    if onoff_state: #if set to on/true/1/high
        while GPIO.input(in_pin) != onoff_state: #when input is on/true/high/1
            GPIO.output(out_pin, 1) #set output high
            time.sleep(0.1) #.1 sec
            GPIO.output(out_pin, 0) #set output low
            time.sleep(0.5) #.5 sec
            if iter > max_iter: #if max is reached
                logging.error(f"Failed to match state for pin {in_pin} after {max_iter} iterations")
                return -1 #return -1 = error
            iter += 1 # increment/add iter counter 
        return 0 # return 0 = successful
    return 0 # return 0 = successful

for pin_pair in G_PINS:
    ONOFF(pin_pair[0], pin_pair[1], False) #turn off all pin pairs

def start_process(n):
    ONOFF(G_PINS[n][0], G_PINS[n][1], True) #turn on all pin pairs
    return wait_for_device(n)

def run_command(command, timeout=None):
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output, error = process.communicate(timeout=timeout)
        return process.returncode, output, error #obtain output and error
    except subprocess.TimeoutExpired:
        process.kill() #kill process
        output, error = process.communicate()
        logging.error(f"Command timeout expired: {error.decode()}")
        return -1, output, error #error/issue

def buttonProc():
    threads = [] #threads
    success_pins = [] #successful pins
    failed_pins = [] #failed pins

    input_states = [GPIO.input(pin) for pin in INPUT_PIN_NUMBERS] #read input status

    if any(input_states): #if input high/1/true/on
        for pin in OUTPUT_PIN_NUMBERS:
            GPIO.output(pin, 1) #turn on output when input is detected on (voltage detected)

        for i, pin_pair in enumerate(G_PINS):
            thread = Thread(target=handle_pin, args=(i, pin_pair[0], pin_pair[1], success_pins, failed_pins))
            threads.append(thread) #add thread to list
            thread.start() #start thread

        for thread in threads:
            thread.join() #wait for all threads to finish

        for i, pin_pair in enumerate(G_PINS):
            if pin_pair[1] in success_pins:
                status_labels[i].config(text=f"Pin pair {pin_pair[0]} and {pin_pair[1]}: Success", fg='green')
            else:
                status_labels[i].config(text=f"Pin pair {pin_pair[0]} and {pin_pair[1]}: Failed", fg='red')
    else:
        for pin in OUTPUT_PIN_NUMBERS:
            GPIO.output(pin, 0) #output is 0/low/false/off

def buttonFunc():
    x = Thread(target=buttonProc)
    x.start()

def handle_pin(index, in_pin, out_pin, success_pins, failed_pins):
    GPIO.output(out_pin, 1) #output high
    time.sleep(1) #wait 1 sec
    command_success = False
    retries = 0 # set retries as 0 (will be added if command fails, and / max will be 3)
    letter = 'a' # set letter as 'a' (if not found, will add and move on to the next letter and checks if found in file)

    while not command_success and retries < 3: #3rd try
        os.system("/home/pi/rpiboot_wraper.sh")
        update_progress(index, 30) #bar 30%
        time.sleep(15) #wait 15 sec

        fileName = f'/dev/sd{letter}'
        if os.path.exists(fileName):
            command_success = True
            logging.info(f"Device found at {fileName} for pin {out_pin}")
        else:
            logging.warning(f"Retrying command for pin {out_pin} (Attempt {retries + 1})")
            retries += 1 
            letter = chr(ord(letter) + 1)

    if command_success:
        dd_command = "sudo dd bs=4M if=Zyrlo_2022_08_14_RC1.img of=/dev/sdb conv=fsync"
        logging.info("Running dd command...")
        update_progress(index, 60)
        ret_code, dd_output, dd_error = run_command(dd_command)

        while True:
            status_command = "status=progress"
            ret_code, status_output, status_error = run_command(status_command)
            if ret_code == 0:
                logging.info("dd command completed successfully")
                break
            else:
                logging.error(f"Error during status check: {status_error.decode()}")
                logging.error(f"Output during status check: {status_output.decode()}")
            time.sleep(30)

        update_progress(index, 100)
        success_pins.append(out_pin)
    else:
        logging.error(f"Command failed on pin {out_pin} after 3 attempts")
        failed_pins.append(out_pin)

def on_closing():
    GPIO.cleanup()
    logging.info("GPIO cleaned up")
    sys.exit()

# Initialize GUI
window = tk.Tk()
window.geometry("900x900")
window.protocol("WM_DELETE_WINDOW", on_closing)
window.configure(bg='lightgrey')

progress_bars = {}
status_labels = {}
star_labels = {}

def reset_progress():
    for i in range(len(G_PINS)):
        progress_bars[i]['value'] = 0
        status_labels[i].config(text=f"Status for pin pair {G_PINS[i][0]} and {G_PINS[i][1]}", fg='black')
        star_labels[i].config(fg='black')
        GPIO.output(G_PINS[i][1], 0)
    logging.info("Progress and status reset")

button_run = tk.Button(window, text="Run Reboot", command=buttonFunc, fg='white', bg='black')
button_run.pack(pady=10)

button_reset = tk.Button(window, text="Reset", command=reset_progress, fg='white', bg='red')
button_reset.pack(pady=10)

for i, pin_pair in enumerate(G_PINS):
    frame = tk.Frame(window, bg='lightgrey')
    frame.pack(anchor='w', padx=20, pady=5)

    label = tk.Label(frame, text=f"Progress for pin pair {pin_pair[0]} and {pin_pair[1]}", bg='lightgrey')
    label.pack(side='left', pady=10)

    star_label = tk.Label(frame, text="â˜…", font=("Arial", 24), bg='lightgrey')
    star_label.pack(side='left', padx=10)
    star_labels[i] = star_label

    progress_bar = ttk.Progressbar(frame, orient='horizontal', length=300, mode='determinate')
    progress_bar.pack(side='left', padx=20)
    progress_bars[i] = progress_bar

    status_label = tk.Label(frame, text=f"Status for pin pair {pin_pair[0]} and {pin_pair[1]}", bg='lightgrey')
    status_label.pack(side='left', pady=10)
    status_labels[i] = status_label

def update_progress(index, value):
    progress_bars[index]['value'] = value
    window.update_idletasks()

def update_star_colors():
    for i, pin_pair in enumerate(G_PINS):
        if GPIO.input(pin_pair[0]) == GPIO.HIGH:
            star_labels[i].config(fg='green')
        else:
            star_labels[i].config(fg='red')
    window.after(500, update_star_colors)

update_star_colors()

try:
    window.mainloop()
except KeyboardInterrupt:
    logging.info("KeyboardInterrupt caught, cleaning up GPIO and exiting")
    GPIO.cleanup()
    sys.exit()
